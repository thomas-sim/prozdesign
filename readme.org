#+STARTUP: content
#+STARTUP: indent

* TODO Information about the project
* Roadmap of the project
** DONE implementation correcte du sreg
*** DONE toplevel
*** DONE changement en tête decodeur
** DONE Functionning LEDs and switches
*** DONE modification .xdc
*** DONE création ports.vhd
*** DONE modification decoder_memory
- pind = boutons = "000" & btnR & btnU & btnD & btnL & btnEnter;
- pinc = switches de 15 à 8
- pinb = switches de 7 à 0
- portc = led de 15 à 8
- portb = led de 7 à 0
*** DONE modification top_level
** TODO Implementation of the seven segment display
** TODO Modification of the way the stack is implemented
*** DONE General change for the stack
Right now, stacks and RET/CALL instructions are working, but the synthesis at
the end isn't using the SRAM of the FPGA but is making everything with
flip-flops.
In order to make it right : follow the freaking SRAM template !
**** DONE se documenter sur les différents types de SRAM ?
**** DONE data_memory contient un sous-élément SRAM
L'élément SRAM sera l'exacte copie du template SRAM
*** TODO correct implementation of the jumps
-> making it in two cycles ?
WTF do I mean by that ?
** TODO implementation of the stack
Push & pop instruction
*** DONE Decoder (use code from old_master)
- [X] signaux en sortie : stack_enable
- [X] set right output register
*** DONE decoder_memory (use code from old_master)
- [X] stack enable -> memory is chosen from multiplexor
- [X] gestion du SP
*** TODO top level
- [ ] modifier decoder
- [ ] modifier decoder_memory
*** TODO test simulation + test ASM
- [ ] simulation "de base"
- [ ] écrire asm qui push 1, 2, 3, etc dans la stack et pop à chaque fois qu'on appuie sur un bouton
- [ ] tester sur hardware
*** TODO améliorations
- [ ] se débarrasser de al variable local_stack_pointer ?
** TODO implementation of RJMP
** TODO Pipelines !
* List of the instructions that should be implemented
* Things learned in that project
** switch to Emacs
Having to use emacs after having been converted to vim wasn't so easy at first,
but I think that I have now adopted Emacs, maybe even for good ! Well, a
totally Vim flavored emacs (thank you my dear Evil !) but still, Emacs.
** Git !
 - intensive usage of git during the project
 - seeing the utility of branches, stashes and regular commits even for a solo
project
** VHDL
Obviously, a lot of VHDL is learned with this project !
*** Software vs Hardware engineering
When developping on hardware, always have in mind how the hardware will be
generated and that means trying to stick to templates and do NOT try to tweak
them. Tweaks should go arouuuuund !
** General programming skills
*** New features developpement cycle
This project is making me realise how much the cycle =implement -> test ->
debug -> commit= is important and efficient. I still have much trouble applying
it for big new features.

For exemple : adding the instructions LD/ST. A lot of changes had to be done
before a actual test could be done (especially the changes in top_level.vhd
that always demands a lot of attention).

A solution could be to right a short test-bench in order to be able to test the
specific developped component.
